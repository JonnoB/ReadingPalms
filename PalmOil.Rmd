---
title: "Untitled"
output: html_document
---


. Load in all the layers
. Subset data
. Represent as vector
. bind vectors of each layer into single frame of multiple features
. Train on outcome

. Classify for whole image
. Overalay shape files
. Classify areas as conflict or not.
. Calculate local percentage conflict and local tonnage.

Additional Ideas
. Likely owner
. Expansion Risk
. Time of expansion

##Useful websites for feature engineering
http://landsat.usgs.gov/band_designations_landsat_satellites.php

http://www.harrisgeospatial.com/Learn/WhitepapersDetail/TabId/802/ArtMID/2627/ArticleID/13742/Vegetation-Analysis-Using-Vegetation-Indices-in-ENVI.aspx

http://web.pdx.edu/~emch/ip1/bandcombinations.html



```{r}
packages <- c("tidyverse", "rgdal", "raster", "gridExtra", "caret","randomForest","xgboost", "e1071", "snow", "RColorBrewer", "rgeos", "xtable", "RStoolbox")

#This piece of code will check to see if the packages you want to load are installed if they aren't it will install them
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

invisible(sapply(packages, library, character.only = TRUE))

#save the starting directory as a variable
basewd <-getwd()

select <-dplyr::select

mode<-"cloud"

if(mode == "cloud"){
  palmbase <-"~/Dropbox/PalmOil"
  TIFF <- "~/Dropbox/PalmOil/Tiff"
  forestshapefile <- "~/Dropbox/PalmOil/ForestShape"
  palmconc<-"~/Dropbox/PalmOil/palmconc"
} else {
  palmbase <-"~/Dropbox/PalmOil"
  TIFF <- "C:/Users/Gail/Desktop/TiffTest"
  }

setwd(palmbase)
```


Function used later in the analysis
```{r}
#Compresses a data frame to the mean value of a square set of cells in a dataframe
#df = A datframe
#merge = the number of cell in the x and y direction to merge
#Requires dplyr 

CompressDf <-function(df,merge = 5){
  
  print("Compressing data along rows")
  
  totrows <-nrow(df)
  remainder <- merge-(totrows %%merge)
  numgroups <-(totrows +remainder)/merge
  
  #rearrange dataframe columns and aggreagte into the predefined groups of size merge
  #rows and columns are first ordered by similarity
  test <- df%>% as.data.frame %>%
    mutate(rowID =rep(1:numgroups,each=merge)[1:totrows]) %>%
    group_by(rowID) %>% summarise_all(funs(mean)) %>%
    select(-rowID) #add in -rows again is the rows data is commented back in
  
  print("Compressing data along Columns")
  #allows the grouping to be flexible in the case that the dataframe changes size
  totcols <-ncol(test)
  remainder <- merge-(totcols %%merge)
  numgroups <-(totcols +remainder)/merge
  
  
  #aggregate again transposing the data frame and aggregating by the smart meters
  test <- t(test) %>% data.frame %>% 
    mutate(rowID =rep(1:numgroups,each=merge)[1:totcols]) %>%
    group_by(rowID) %>% summarise_all(funs(mean)) %>%select(-rowID) %>%
    t %>% data.frame %>% mutate( rowID = 1:nrow(.)) 
  
}
```


```{r}
CreateTiffFrame <- function(img, trainData, responseCol){
 #This function outputs a data frame with a column for the pixel data and a column for the output variable, for a stacked raster it will include a column for each band
  
TiffFrame <- lapply(1:length(unique(trainData[[responseCol]])), function(i){    
          category <- unique(trainData[[responseCol]])[i]
          categorymap <- trainData[trainData[[responseCol]] == category,]
          dataSet <- extract(img, trainData[trainData[[responseCol]] == category,] )
          dataSet <- lapply(dataSet, as.data.frame) %>% bind_rows %>% mutate( Class = category)
          }) %>% bind_rows()
}
```


untar data
```{r}
setwd(TIFF)

#all above band 7 is corrupted or something, band bQA is nothing 
files <- list.files(pattern =".TIF")

#finds the correct bands and orders them correctly
filewant <- files %>% sub("LC81190622016273LGN00_B", "", .) %>% 
  sub(".TIF", "", .) %>% as.numeric %>% base::match(1:7, .)

LSI<- lapply(files[filewant], brick)%>% stack  %>%
  setNames(sub(".+_", "", names(.))) 
```



ImportBrick
```{r}


setwd(palmbase)
 ggRGB(LSI, r=4,g=3,b=2) + labs(title = "The original satellite image shown in natural colours") +
             theme(axis.title= element_blank(),
                axis.text = element_blank(),
                axis.ticks = element_blank(),
                panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(),
                legend.position = "right",
                legend.key = element_blank(),
                plot.title = element_text(hjust = 0.5))
ggsave("BaseImage.png")

#img <- brick("FakeForest1.tif")

setwd(forestshapefile)
trainData <- shapefile("ForestLC8119.shp")
#trainData <- shapefile("FakeFores1_shape.shp")

#Dropbox wasn't updating in AWS so I had to manually filter out this NA
#trainData <- subset(trainData, trainData$Class %in% unique(trainData$Class)[-6])


plot(trainData)

```

```{r}


if (!file.exists(file.path(palmbase, "TiffFrame.RDS"))){
TiffFrame <- CreateTiffFrame(LSI, trainData, "Class")

TiffFrame <-TiffFrame %>% mutate(TNDVI = sqrt(((B5-B4)/(B5+B4))+1), 
                                  ForCrop1 = B3/B2,
                                  ForCrop2 = B7/B2,
                                  WatLan1 = B6/B7,
                                  WatLan2= (B4+B5)/(B6*2))
 setwd(palmbase)
 saveRDS(TiffFrame,"TiffFrame.RDS")
 } else {

    TiffFrame <- readRDS("TiffFrame.RDS")
   
 }

Classdf <- data.frame(Class = TiffFrame$Class) %>% 
  mutate(ClassNum =  Class %>% 
           as.factor %>% 
           as.numeric -1) #Classes have to start at 0

ClassCodes <- unique(Classdf)

set.seed(1987)
 trainvect<- sample(1:nrow(TiffFrame), 0.8*nrow(TiffFrame))

 Tiffmat<-as.matrix(select(TiffFrame, -Class))

if (!file.exists(file.path(palmbase, "Mod1.rds"))){
 Mod1 <- xgboost(Tiffmat[trainvect,],
        label = Classdf$ClassNum[trainvect],
                    max.depth=6,
                    eta = 0.10,
                    nround = 200,
                    objective = "multi:softmax",
                    num_class = 5,
                    eval_metric ="merror",
                    missing="NAN")



#save model as it takes a long time to build
setwd(palmbase)

saveRDS(Mod1, "Mod1.rds") 
} else {

  Mod1 <-  readRDS(file.path(palmbase, "Mod1.rds"))
}

Preds1 <- predict(Mod1, Tiffmat[-trainvect,], missing="NAN")
confusionMatrix(Preds1, Classdf$ClassNum[-trainvect])

 
#  Tiffmat<-as.matrix(select(TiffFrame, -Class))
# Mod1 <- xgboost(Tiffmat[trainvect,],
#         label = TiffFrame$Class[trainvect]=="Plantation",
#         max.depth=5, 
#                     eta=0.10,
#                     nround = 100, 
#                     objective = "binary:logistic")
# 
# 
# Preds1 <- predict(Mod1, Tiffmat[-trainvect,])
# confusionMatrix(Preds1>0.5, TiffFrame$Class[-trainvect]=="Plantation")


importance <- xgb.importance(feature_names = colnames(Tiffmat), model = Mod1)
barplot(importance$Gain)

setwd(palmbase)
importance %>%  mutate(Feature = factor(Feature, levels = Feature[order(-importance$Gain)])) %>% 
  ggplot(., aes(x = Feature, y = Gain)) +geom_bar(stat="identity") +
  ggtitle("Variable Importance for classification\nof rural Indonesia using Landsat 8 Images")
ggsave("VarImp.png")
```



```{r}


if(!file.exists(file.path(palmbase,"predmat.RDS"))){

    #Convert entire image
    imgmat <-as.data.frame(LSI) %>% mutate_all(as.numeric) %>% 
      mutate(TNDVI = sqrt(((B5-B4)/(B5+B4))+1), 
          ForCrop1 = B3/B2,
          ForCrop2 = B7/B2,
          WatLan1 = B6/B7,
          WatLan2= (B4+B5)/(B6*2)) %>% 
      as.matrix()
    
    #predict class of whole image
    preds <- predict(Mod1, imgmat, missing = "NAN")
    
    
    #Change the prediction vector back into a raster image.
    predmat <- matrix(preds, nrow= 7771, byrow = TRUE) #>0.5
    saveRDS(predmat, "predmat.RDS")
}else{
  setwd(palmbase)
  predmat <- readRDS("predmat.RDS")}




CompressedMap <- lapply(0:4, function(n){
  print(n)
  ((predmat==n)*1) %>% CompressDf(., merge=10) %>%
    gather(.,key = "columnID", value =Percentvalid, -rowID )%>%
    mutate(columnID = sub("X","", columnID) %>% as.integer) 
})


CompressedMap <-left_join(CompressedMap[[1]],CompressedMap[[2]], by =c("rowID", "columnID")) %>%
  left_join(.,CompressedMap[[3]], by =c("rowID", "columnID")) %>%
  left_join(.,CompressedMap[[4]], by =c("rowID", "columnID")) %>%
  left_join(.,CompressedMap[[5]], by =c("rowID", "columnID")) %>% 
  setNames(c("rowID", "columnID", "Cloud", "Empty", "Forest", "Plantation", "Water" )) %>%
  mutate(Type = c("Cloud", "Empty", "Forest", "Plantation", "Water" )[max.col(.[,3:7])])

setwd(palmbase)
ggplot(CompressedMap, aes(y=-rowID, x= columnID, fill = Type )) +
    geom_raster() +scale_fill_manual(values = c("white","black", "darkgreen", "green", "blue"))+#theme_bw() +
    coord_equal() + labs(title = "Results of classifying the satellite image") + 
    theme(axis.title= element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.key = element_blank(),
    plot.title = element_text(hjust = 0.5)) 
  ggsave("ModMap.png")

```


extract  useful stats from the matrix

. 1 pixel is equivalent to 0.009 hectares of land
. 1 hectare of land can produce 3.69 tonnes per hectare.
. 1km^2 is equal to 100 hactares
```{r}
px <- sapply(0:4, function(n) sum(predmat ==n))
ppt <-780 #price per tonne

imagedata <- ClassCodes %>% arrange(ClassNum) %>% mutate(pixels = px, km2 = round(pixels * 9e-5))
imagedata

#Tonnes of Palm Oil Equivalent

TonnesOil <- imagedata$km2[imagedata$Class== "Plantation"] * 3.69*100
#value of oil in USD

TonnesOil*ppt/1e6

```


```{r}
#load concessions
setwd(palmconc)
IndoPalmConc <- shapefile("Indonesia_oil_palm_concessions.shp")
IndoPalmConc <- spTransform(IndoPalmConc,CRS=crs(LSI))

predrast <- raster(predmat)
extent(predrast) <- extent(LSI)

#This calculation takes  a long time if you don't need to do it multiple times it's better
if(!file.exists(file.path(palmbase,"LegalPlantationMask.rds"))){

  maskrast<- matrix(1:length(predmat), nrow = 7771) %>% raster
  
  extent(maskrast) <- extent(LSI)

  LegalPlantationMask <- extract(maskrast, IndoPalmConc) %>% 
  lapply(., as.data.frame) %>% bind_rows

  LegalPlantationMask <- LegalPlantationMask[,1] %>% as.integer
  
  setwd(palmbase)

  saveRDS(LegalPlantationMask, "LegalPlantationMask.rds")
}else{
LegalPlantationMask <- readRDS("LegalPlantationMask.rds")
  }


maskrast<- matrix(1, nrow = 7771, ncol =7611 ) 
maskrast[LegalPlantationMask] <- 0

predmat2 <- predmat

#create a logical mask
predmat2 <- predmat2 * maskrast

#class everything that is platnation but outside the legal zones as 2 everything else = 0
predmat2 <- (predmat2 == 3)*2

#add the two matrices together so that a 6 is the level for conflict palm
predmat2 <- predmat + predmat2

#compress the new matrix
CompressedMap <- lapply(0:5, function(n){
  print(n)
  ((predmat2==n)*1) %>% CompressDf(., merge=10) %>%
    gather(.,key = "columnID", value =Percentvalid, -rowID )%>%
    mutate(columnID = sub("X","", columnID) %>% as.integer) 
})

#organise creating the conflict level
CompressedMap2 <-left_join(CompressedMap[[1]],CompressedMap[[2]], by =c("rowID", "columnID")) %>%
  left_join(.,CompressedMap[[3]], by =c("rowID", "columnID")) %>%
  left_join(.,CompressedMap[[4]], by =c("rowID", "columnID")) %>%
  left_join(.,CompressedMap[[5]], by =c("rowID", "columnID")) %>% 
  left_join(.,CompressedMap[[6]], by =c("rowID", "columnID")) %>%
  setNames(c("rowID", "columnID", "Cloud", "Empty", "Forest", "Plantation", "Water","Conlfict" )) %>%
  mutate(Type = c("Cloud", "Empty", "Forest", "Plantation", "Water", "Conflict" )[max.col(.[,3:8])] %>%
           as.factor %>% fct_relevel("Empty") %>% fct_relevel("Conflict", after = Inf))

#plot with the conflict level included
ggplot(CompressedMap2, aes(y=-rowID, x= columnID, fill = Type )) +
    geom_raster() +scale_fill_manual(values = c("black","white", "darkgreen", "green", "blue", "red"))+#theme_bw() +
    coord_equal() + labs(title = "Areas of conflict palm") + 
    theme(axis.title= element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    legend.key = element_blank(),
    plot.title = element_text(hjust = 0.5)) 

TypeSplit <- table(unlist(predmat2)) %>% test %>% as.data.frame %>% select(-Var1) %>% rename(Pixels = Freq) %>%
  mutate(Type = c( "Empty", "Cloud", "Forest", "Plantation", "Water", "Conflict Palm"),
         `Km^2`= round(Pixels *9e-5),
         `Percent of Total` = round(Km2/sum(Km2)*100)) %>% 
  filter(Type != "Empty") %>% select(-Pixels)

output<- data_frame(`Percent Conflict` = round(TypeSplit[5,2]/(TypeSplit[3,2]+TypeSplit[5,2])*100),
            `Tonnes Production` = (TypeSplit[3,2]+TypeSplit[5,2])*3.69*100,
            `Tonnes Conflict` = (TypeSplit[5,2])*3.69*100,
            `Value of Conflict (MUSD)` = round((TypeSplit[5,2])*3.69*100 * ppt/1e6))


TypeSplit %>% stargazer(., type="html", summary = FALSE)

output %>% gather() %>% stargazer(., type="text", summary = FALSE)


TypeSplit %>% kable
```



