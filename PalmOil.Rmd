---
title: "Untitled"
output: html_document
---


. Load in all the layers
. Subset data
. Represent as vector
. bind vectors of each layer into single frame of multiple features
. Train on outcome

. Classify for whole image
. Overalay shape files
. Classify areas as conflict or not.
. Calculate local percentage conflict and local tonnage.

Additional Ideas
. Likely owner
. Expansion Risk
. Time of expansion

##Useful websites for feature engineering
http://landsat.usgs.gov/band_designations_landsat_satellites.php

http://www.harrisgeospatial.com/Learn/WhitepapersDetail/TabId/802/ArtMID/2627/ArticleID/13742/Vegetation-Analysis-Using-Vegetation-Indices-in-ENVI.aspx

http://web.pdx.edu/~emch/ip1/bandcombinations.html



```{r}
packages <- c("tidyverse", "rgdal", "raster", "gridExtra", "caret","randomForest","xgboost", "e1071", "snow", "RColorBrewer")

#This piece of code will check to see if the packages you want to load are installed if they aren't it will install them
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

invisible(sapply(packages, library, character.only = TRUE))

#save the starting directory as a variable
basewd <-getwd()

select <-dplyr::select

mode<-"cloud"

if(mode == "cloud"){
  palmbase <-"~/Dropbox/PalmOil"
  TIFF <- "~/Dropbox/PalmOil/Tiff"
  forestshapefile <- "~/Dropbox/PalmOil/ForestShape"
} else {
  palmbase <-"~/Dropbox/PalmOil"
  TIFF <- "C:/Users/Gail/Desktop/TiffTest"
  }

setwd(palmbase)
```


```{r}
CreateTiffFrame <- function(img, trainData, responseCol){
 #This function outputs a data frame with a column for the pixel data and a column for the output variable, for a stacked raster it will include a column for each band
  
TiffFrame <- lapply(1:length(unique(trainData[[responseCol]])), function(i){    
          category <- unique(trainData[[responseCol]])[i]
          categorymap <- trainData[trainData[[responseCol]] == category,]
          dataSet <- extract(img, trainData[trainData[[responseCol]] == category,] )
          dataSet <- lapply(dataSet, as.data.frame) %>% bind_rows %>% mutate( Class = category)
          }) %>% bind_rows()
}
```


untar data
```{r}
setwd(TIFF)

#all above band 7 is corrupted or something, band bQA is nothing 
files <- list.files(pattern =".TIF")

#finds the correct bands and orders them correctly
filewant <- files %>% sub("LC81190622016273LGN00_B", "", .) %>% 
  sub(".TIF", "", .) %>% as.numeric %>% base::match(1:7, .)

LSI<- lapply(files[filewant], brick)%>% stack  %>%
  setNames(sub(".+_", "", names(.))) 
```



ImportBrick
```{r}

plotRGB(LSI,r=4,g=3,b=2, scale=800, stretch = "Lin")

#img <- brick("FakeForest1.tif")

setwd(forestshapefile)
trainData <- shapefile("ForestLC8119.shp")
#trainData <- shapefile("FakeFores1_shape.shp")

#Dropbox wasn't updating in AWS so I had to manually filter out this NA
#trainData <- subset(trainData, trainData$Class %in% unique(trainData$Class)[-6])


plot(trainData)

```

```{r}

TiffFrame <- CreateTiffFrame(LSI, trainData, "Class")

TiffFrame <-TiffFrame %>% mutate(TNDVI = sqrt(((B5-B4)/(B5+B4))+1), 
                                  ForCrop1 = B3/B2,
                                  ForCrop2 = B7/B2,
                                  WatLan1 = B6/B7,
                                  WatLan2= (B4+B5)/(B6*2))

Classdf <- data.frame(Class = TiffFrame$Class) %>% 
  mutate(ClassNum =  Class %>% 
           as.factor %>% 
           as.numeric -1) #Classes have to start at 0

ClassCodes <- unique(Classdf)

set.seed(1987)
 trainvect<- sample(1:nrow(TiffFrame), 0.8*nrow(TiffFrame))

 Tiffmat<-as.matrix(select(TiffFrame, -Class))

 Mod1 <- xgboost(Tiffmat[trainvect,],
        label = Classdf$ClassNum[trainvect],
                    max.depth=6,
                    eta = 0.10,
                    nround = 200,
                    objective = "multi:softmax",
                    num_class = 5,
                    eval_metric ="merror",
                    missing="NAN")


Preds1 <- predict(Mod1, Tiffmat[-trainvect,], missing="NAN")
confusionMatrix(Preds1, Classdf$ClassNum[-trainvect])

#save model as it takes a long time to build
setwd(palmbase)
#Mod1 <- readRDS("Mod1.rds")
saveRDS(Mod1, "Mod1.rds") 
 
#  Tiffmat<-as.matrix(select(TiffFrame, -Class))
# Mod1 <- xgboost(Tiffmat[trainvect,],
#         label = TiffFrame$Class[trainvect]=="Plantation",
#         max.depth=5, 
#                     eta=0.10,
#                     nround = 100, 
#                     objective = "binary:logistic")
# 
# 
# Preds1 <- predict(Mod1, Tiffmat[-trainvect,])
# confusionMatrix(Preds1>0.5, TiffFrame$Class[-trainvect]=="Plantation")


importance <- xgb.importance(feature_names = colnames(Tiffmat), model = Mod1)
barplot(importance$Gain)

setwd(palmbase)
importance %>%  mutate(Feature = factor(Feature, levels = Feature[order(-importance$Gain)])) %>% 
  ggplot(., aes(x = Feature, y = Gain)) +geom_bar(stat="identity") +
  ggtitle("Variable Importance for classification\nof rural Indonesia using Landsat 8 Images")
ggsave("VarImp.png")
```



```{r}

#Convert entire image
imgmat <-as.data.frame(LSI) %>% mutate_all(as.numeric) %>% 
  mutate(TNDVI = sqrt(((B5-B4)/(B5+B4))+1), 
      ForCrop1 = B3/B2,
      ForCrop2 = B7/B2,
      WatLan1 = B6/B7,
      WatLan2= (B4+B5)/(B6*2)) %>% 
  as.matrix()

#predict class of whole image
preds <- predict(Mod1, imgmat, missing = "NAN")


#Change the prediction vector back into a raster image.
predmat <- matrix(preds, nrow= 7771, byrow = TRUE) #>0.5
predrast <- raster(predmat)
extent(predrast) <- extent(LSI)



plot(predrast, breaks = c(-1,0,1,2,3,4), col = c("white", "black","forestgreen", "green", "blue") )
df<- rasterToPoints(predrast)
df <- data.frame(df)
names(df)<- c("Longitude", "Latitude", "Type")

ggplot(df, aes(y=Latitude, x=Longitude, fill=Type)) +
geom_raster()
+theme_bw() +
coord_equal() +theme(axis.title.x = element_text(size=16),
axis.title.y = element_text(size=16, angle=90),
axis.text.x = element_text(size=14),
axis.text.y = element_text(size=14),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
legend.position = "right",
legend.key = element_blank()
)

```


extract  useful stats from the matrix

. 1 pixel is equivalent to 0.009 hectares of land
. 1 hectare of land can produce 3.69 tonnes per hectare.
. 1km^2 is equal to 100 hactares
```{r}
px <- sapply(0:4, function(n) sum(predmat ==n))

imagedata <- ClassCodes %>% arrange(ClassNum) %>% mutate(pixels = px, km2 = round(pixels * 9e-5))
imagedata

#Tonnes of Palm Oil Equivalent

TonnesOil<- imagedata$km2[imagedata$Class== "Plantation"] * 3.69*100
#value of oil in USD

TonnesOil*692/1e6

```


```{r}
setwd(file.path(palmbase, "DummyLegal"))

Legalshape <- shapefile("DummyLegal.shp")
test <- as.matrix(Legalshape)

plot(Legalshape)


dataSet <- extract(LSI, trainData ) %>% lapply(., as.data.frame) %>% bind_rows

LegalProd <- ClassCodes %>% arrange(ClassNum) %>% 
  mutate(pixels = sapply(0:4, function(n) sum(dataSet ==n)), 
         km2 = round(pixels * 9e-5))

names(Legalshape)[2] <- "Class"
test <- CreateTiffFrame(predrast, Legalshape, "LP")

```


Alternative Method of working out what is legal and what isn't

```{r}


Preds1 <- predict(Mod1, Tiffmat, missing="NAN")
confusionMatrix(Preds1, Classdf$ClassNum)

```

